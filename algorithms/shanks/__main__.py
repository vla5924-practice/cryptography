import math

def baby_step_giant_step(g, h, p):
    """
    Алгоритм Шенкса для вычисления дискретного логарифма.
    Ищем минимальное неотрицательное x, такое что g^x ≡ h (mod p).
    
    :param g: основание логарифма
    :param h: результат экспоненциального возведения
    :param p: модуль, должно быть простое число
    :return: значение x или None если решение не найдено
    """
    # Шаг 1: Определяем размер таблицы m
    m = math.isqrt(p - 1) + 1  # используем ближайший больший целочисленный квадратный корень
    
    # Шаг 2: Создаем таблицу "младших шагов"
    baby_steps = {}
    
    # Вычисляем и сохраняем значения g^(j) mod p для j от 0 до m-1
    for j in range(m):
        value = pow(g, j, p)
        baby_steps[value] = j
        # Сохраняем результат в виде {value: j}
    
    # Шаг 3: Вычисляем обратное для гигантского шага
    # g^(-m) = (g^m)^(-1) (mod p)
    c = pow(g, m * (p - 2), p)
    
    # Шаг 4: Начинаем гигантские шаги
    gamma = h  # Начинаем с h и будем изменять на каждом шаге
    for i in range(m):
        # Проверяем, существует ли gamma в baby_steps
        if gamma in baby_steps:
            return i * m + baby_steps[gamma]  # Решение найдено: возвращаем x = i * m + j
        
        # Переходим к следующему гигантскому шагу
        gamma = (gamma * c) % p
    
    return None  # Если решение не найдено

# Пример использования
if __name__ == "__main__":
    # Пример данных
    g = 2  # основание
    h = 22 # результат экспоненциального возведения
    p = 29 # простое число

    result = baby_step_giant_step(g, h, p)
    if result is not None:
        print(f"Дискретный логарифм для g = {g}, h = {h}, по модулю p = {p} равен x = {result}")
    else:
        print("Решение не найдено.")
